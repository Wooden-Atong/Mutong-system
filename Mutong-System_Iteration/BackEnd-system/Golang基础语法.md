# 1 变量

## 1.1 概念

变量相当于内存中一个数据存储空间的表示。

## 1.2 基本步骤

**1）声明变量（定义变量）**

**2）赋值**

（如果**声明时就赋值**了，就叫初始化变量）

**3）使用**

## 1.3 变量使用的注意事项

**1）变量表示内存中的一个存储区域，该区域有自己的名称（变量名）和类型（数据类型）。**

**2）Golang变量使用的三种方式：**

​		**第一种：**指定变量类型，**声明后若不赋值，使用默认值**。

​		**第二种：**根据值自行判断变量类型（**类型推导**）。

​		**第三种：**省略var，使用 ：= 进行声明和赋值变量，但要注意**：=左侧的变量不能已经声明过，否则报编译错**。

**3）一次性声明多个变量**

```go
//(1) 声明 多个相同类型变量 (不能用此方法声明多种不同类型变量)，但不赋值
var n1, n2, n3 int
//(2) 用var声明 多种类型变量 ，利用类型推导
var n4,name = 100, "Tom"
//(3) 依然用var声明(只不过用括号代替省略逗号) 多种类型变量 ，利用类型推导
var (
  n6 = 1
  n7 = 2
  n = "Jerry"
)
//(4) 用：=声明 多种类型变量 ，利用类型推导
n5, sex := 200, "F"
//(5) 用var声明多个相同类型变量且赋值
var n6,n7 int64 = 3,4
```

**4）**该**区域的数据值** 可以在 **同一类型范围** 内 **不断变化**

**5）变量 = 变量名 + 值 + 数据类型**，变量的三要素

**6）变量在同一作用域（在一个函数或者代码块）内不能重名**

## 1.4 变量的数据类型

### 1.4.1 基本数据类型

#### 1.4.1.1 数值型

后面带的数字表示了这个长度，8就是一个字节，16就是2个字节，以此类推。

##### 1.4.1.1.1 整数类型（int，int8，int16，int32（别名rune），int64，unit，unit8（别名byte），unit16，unit32，unit64）**



<img src="/Users/mac/Desktop/截屏2024-04-07 下午3.27.22.png" alt="截屏2024-04-07 下午3.27.22" style="zoom:40%;" />

<img src="/Users/mac/Desktop/截屏2024-04-07 下午3.31.26.png" alt="截屏2024-04-07 下午3.31.26" style="zoom:40%;" />

<img src="/Users/mac/Desktop/截屏2024-04-07 下午3.34.22.png" alt="截屏2024-04-07 下午3.34.22" style="zoom:47%;" />

**默认值：**0

**注意⚠️：**

1）unit表示无符号的；int表示有符号的。

2）rune表示范围是int32但是unicode码（而非utf-8），所有可以处理一些中文字符；byte表示范围和unit8一样，但可以存储字符。

3）int 和 unit 是 4字节 还是 8字节 取决于 32位操作系统 还是 64位操作系统。

4）如果不给值整型类型，默认是int。

5）如何在程序中查看某个变量占用的字节大小和数据类型：

```go
var n1  int64 = 10
//fmt.Printf表示格式化输出，%T表示变量的类型，%d表示输出一个整数。
//unsafe.Sizeof(n1)输出n1占用的字节数
fmt.Printf("n1 的 类型 %T, n1 占用的 字节数 %d", n1, unsafe.Sizeof(n1))
```

6）Golang程序使用整形变量，采用“保小不保大”的原则，节省空间。

7）计算机最小存储单位：bit（位）；计算机基本存储单位：byte（字节）。1 byte = 8 bits。



##### **1.4.1.1.2浮点类型（float32，float64）**

**默认值：**0

**注意⚠️：**

1）float32相当于单精度（4个字节），float64相当于双精度（8个字节）。

2）浮点数在机器中的存放形式：浮点数 = 符号位 + 指数位 +尾数位 。

3）浮点数都是有符号的。

4）浮点数精度可能损失；64位精度要比32位精度大（要保存精度更高的数应该选用float64；通常情况下也建议使用float64）。

5）Golang浮点数有固定范围和字段长度，不受操作系统O S影响。

6）如果不给值浮点类型，默认float64

7）浮点数两种表示形式：

```go
//十进制形式
num1 := 5.12
num2 := .123 // 0.123 必须有小数点，但是0可以省略

//科学计数法形式
num3 := 5.1234e2 // 5.1234 * 10的2次方
num4 := 5.1234E2 // e 和 E 都可以
num5 := 5.1234E-2 // 5.1234 * 10的-2次方
```



#### 1.4.1.2 字符型（无）

**注意⚠️：**

1）Golang没有专门字符型，用**byte存单个字符**。（因此无法直接存储汉字）

2）当我们直接输出byte类型数值，输出的其实是它对应的ASCII码值；如果希望输出对应字符，需要用格式化输出（%c）。

3）在ASCII码表中比如[0-1, a-z, A-Z,...]可以直接保存在byte；但如果一个汉字‘北’它的unicode很大，肯定**超过了byte类型的范围**，但**可以用int保存**。（很有趣，‘北’明明是字符却可以保存在int类型，这也侧面说明了Golang中没有专门的字符型）

4）Golang字符采用**UTF-8编码**（可以理解为UTF-8包含了ASCII码，且扩大了）（**再也没有编码乱码困扰**）。

​		**英文字母 -- 1个字节；汉字 -- 3个字节**。

5）在Golang中**字符的本质是一个整数**，直接输出时是该字符对应的UTF-8编码，也因此**字符类型可以进行运算**（比如var n1 = 10 + 'a' 是合法的，结果为107）。

#### 1.4.1.3 布尔型

**默认值：**false

**注意⚠️：**

1）只能取**true**或**false**；0或1就不行。

2）bool类型占一个字节。

#### 1.4.1.4 字符串

**默认值：**“”

**注意⚠️：**

1）**字符串就是固定长度的字符序列。**传统字符串是字符组成，而**Go的字符串是由单个字节连接起来的**。

2）Golang中字符串的字节使用UTF-8编码标识Unicode文本。

3）字符串一旦赋值，就不能修改了。（**Golang中字符穿不可变**）

4）字符串的两种表示形式：

​		**双引号：**会识别转义字符、特殊字符（**不便于输出原文本**）。

​		**反引号：**以**字符串原生形式输出**，包括特殊字符，可以防止攻击、输出源代码。

5）字符串拼接可以直接用+号，但要留意**如果同一行+的太多了可以换行，但一定要把+号留在上一行**。

#### 1.4.1.5 基本数据类型（除string）的转换

**基本介绍：**Golang在**不同类型的变量之间赋值**需要 **显示转换**，**不能自动转换**。

**基本语法：**

```go
var i int32 = 100
//不论是 高精度转成低精度 还是 低精度转成高精度 还是 转成不同类型，都需要显示转换
var n1 float32 = float32(i)
var n2 int8 = int8(i)
var n3 int64 = int64(i)
```

注意⚠️：

1）被转换的是 **变量存储的数据（即值）**， 而变量本身的数据类型并没有变化。

2）如果从高位转为地位，比如 int64 转成 int8 且这个数int8绝对存不下，编译不会报错，但转换结果会按溢出处理。

3）如果给int8变量赋值127+n(n=10)，很明显溢出但编译器不会报错，结果是溢出处理；如果给int8变量赋值128+n(n=10)，编译器直接报错因为不用计算128已经溢出了。

#### 1.4.1.6 基本数据类型和string的转换

**基本数据类型转string：**

```go
var num1 int = 99
var num2 float64 = 23.34
var b1 bool = true
var str string
//第一种方式：fmt.Sprintf
//整数%d，浮点数%f，布尔型%t，字符型%c
str = fmt.Sprintf("%d", num1)

//第二种方式：使用strconv包函数Format
//可能要先强制转换为int64，因为这个函数接收int64类型，10表示这个数是10进制
str = strconv.FormatInt(Int64(num1),10)
//'f'表示float，10表示小数保留10位，64表示这个小数float64
str = strconv.FormatFloat(num2, 'f' ,10, 64)
//bool比较简单，只用传进来一个参数就好了
str  = strconv.FormatBool(b1)

//第三种方式：使用strconv包中的函数Itoa
//这里要注意传入的要求int，如果num1是int64要先转为int
str = strconv.Itoa(int(num1))
```



**string转基本数据类型：**

```go
var str string = 'true'
var b bool
//使用strconv的Parse
// 注意会返回两个值，第二个为err，我们可以用 _ 忽略。

//只有这一个bool参数，传进来就好了
b, _ = strconv.ParseBool(str)

var str2 string = "123"
var num int64
//10进制 64位
num, _ = strconv.ParseInt(str2, 10 ,64)

var str3 string = "12.12"
var f1 float64
//64表示float64
f1, _ =strconv.ParseFloat(str3, 64)

	//**注意⚠️：要确保这个string类型能转换为有效数据**。比如‘hello’转为整数，golang**如果没有转成功不会报错**，但会将即将要赋值的这个整数 **直接写为默认值** 0。
```

​		



### 1.4.2 派生/复杂数据类型

#### 1.4.2.1 指针（Pointer）

注意⚠️：

1）基本数据类型，变量存的就是值，也叫值类型；获取变量地址，用&，比如 var num int，获取num的地址：&num。

2）指针的定义：

```go
var i int = 10
//1 ptr是一个指针变量
//2 ptr的类型是*int，表示指向int类型数据的一个指针
//3 ptr本身的值是&i，即i变量的地址
var ptr *int = &i
```

3）取出ptr指向的值，使用*ptr，即 i 的值 10.（通过这个方法找到 i 的值是可修改的，因为确实指向了i 的存储空间）

4）声明指针为比如 *float32类型，那就不能接受int变量地址作为指针值，类型不匹配；类似的，指针变量不能接受一个整数或浮点数等其他不是指针类型（地址）的值，类型不匹配。

5）值类型 都有对应的指针类型，形式为 *数据类型。（值类型包括：int系列、float系列，bool，string，数组，结构体struct）

#### 1.4.2.2 数组

#### 1.4.2.3 结构体（struct）

#### 1.4.2.4 管道（channel）

#### 1.4.2.5 函数

#### 1.4.2.6 切片（slice）

#### 1.4.2.7 接口（interface）

#### 1.4.2.8 map

### 1.4.3 值类型和引用类型

#### 1.4.3.1 值类型

**定义**：**变量直接存储值**，内存**通常**在**栈**中分配。

int系列、float系列，bool，string，数组，结构体struct

#### 1.4.3.2 引用类型

**定义**：**变量存储的是一个地址**，这个地址对应的空间才真正存储数据（值），内存**通常**在**堆**上分配。当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收。

指针、slice切片、map、管道channel、interface

## 1.5 标识符的基本使用和命名规范

**标识符基本使用注意⚠️：**

1）_ 是空标识符，只能用于占位，不能直接作为标识符，var _ int = 9是不合法的；但是var num_a = 9 是合法的。

**标识符命名规范注意⚠️：**

1）包名（package后面跟的）尽量和所在文件夹名字一致；不要和标准库名冲突。

2）变量名、函数名、常量名：采用**驼峰法**。比如goodPrice、stuName。

3）如果变量名、函数名、常量名 首字母大写，则可以被其他包访问；如果首字母小写，则只能在本包中使用。（❗️也就是首字母大写是public的；首字母小写是private的）

```go
//一个引用其他包变量示例
package main
import (
	"go_code/demo04/model"
)
func main(){
  //注意这里的model不是因为这个文件夹叫model，同时也和model下的utils.go这个文件名无关
  //而是因为我们要用的这个文件utils.go的包名叫model（package model）
  var i int = model.hereName
}
```

## 1.6 系统保留关键字

例如：break，var 等等。

**定义**：系统已经在用的关键字。

## 1.7 系统预定标识符

例如：append，complex等等。

**定义：**由**基础数据类型**和**系统内嵌函数**组成。

# 2 运算符

**❗️❗️特别说明：Golang不支持三元运算符。**因为Golang设计者希望一个事情只有一种解决方法。（直接if else解决）

## 2.1 算术运算符

**定义：**对数值类型变量进行运算。

### 2.1.1 加 +

### 2.1.2 减 -

### 2.1.3 乘 *

### 2.1.4 除 /

**注意⚠️：**如果两头运算的都是整数，除/的结果也是整数（自动去掉小数部分，不会四舍五入）；如果两头有任意一个浮点数，除/的结果就是浮点数（自动保留小数部分）

### 2.1.5 取模（取余） %

**公式：** a % b = a - ( a / b ) * b

### 2.1.6 自增（自减） ++（--）

**注意⚠️：**

**1）只能当成独立的语句使用**（比如a++），不能赋值也不能比较（i = a++是不合法的，a++ > 0 也是不合法的）。

2）只有后++后--，没有前++前--。

### 2.1.7 字符串相加 +



## 2.2 赋值运算符

### 2.2.1 最简单的赋值 =

### 2.2.2 相加（相减）后赋值 +=（-=）

### 2.2.3 相乘（相除）后赋值 *=（/=）

### 2.2.4 求余后赋值 %=

### 2.2.5 左移（右移）后赋值 <<=（>>=）

### 2.2.6 按位 与 后赋值 &=

### 2.2.7 按位 异或 后赋值 ^=

### 2.2.8 按位 或 后赋值 |=



## 2.3 比较运算符（关系运算符）

**概述：**1）结果都是bool型，要么true要么false。2）经常用在**if结构**的条件中或**循环结构**的条件中。

### 2.3.1 相等 ==

### 2.3.2 不相等 ！=

### 2.3.3 大于（小于） >（<）

### 2.3.4 大于等于（小于等于） >=（<=）



## 2.4 逻辑运算符

**概述：**连接多个条件（一般就是关系表达式），结果为bool值。

### 2.4.1 与 &&

注意⚠️：也叫**短路与**，如果第一个条件为false则第二个条件不会判断，最终false。

### 2.4.2 或 ||

注意⚠️：也叫短路或，如果第一个条件为true则第二个条件不会判断，最终true。

### 2.4.3 非 ！



## 2.5 位运算符

在计算机内部都是以**二进制的补码形式**来进行运算的，所以一下的**位运算符都是在二进制补码基础上按位计算的**。

注意⚠️：

1）下面的位运算符使用，我们用户**输入的是十进制**，只是计算机计算会是二进制，最后**返回默认是十进制**。

2）我们自己**想得到补码**，对于**负数**，**要先拿到原码，然后得到反码，最后得到补码**（反之，想从补码拿到原码，要先到反码（补码减1），然后从反码得到原码（符号位不变，其他取反））。

### 2.5.1 按位与运算符 &

**规则：**两位全为1，结果为1，否则为0.

### 2.5.2 按位或运算符 ｜

**规则**：两位有一个为1，结果为1，否则为0.

### 2.5.3 按位异或运算符 ^

**规则：**两位一个为0，一个为1，结果为1，否则为0.

### 2.5.4 左移运算符 <<

规则：符号位不变，低位补0.

案例：c := 1 << 2 // 0000 0001（1的补码） 左移两位=> 0000 01 用0补低位=> 0000 0100（补码） => 4

### 2.5.5 右移运算符 >>

规则：低位溢出，符号位不变，并用符号位补溢出的高位。

案例：a := 1 >> 2 // 0000 0001（1的补码） 右移两位=> 00 0000 用符号位补溢出的高位=> 0000 0000（补码） => 0 

## 2.6 其他运算符

### 2.6.1 取变量存储地址运算符 &

### 2.6.2 取指针变量对应地址存储的值 *



## 2.7 运算符优先级

注意⚠️：

1）只有**单目运算符、赋值运算符**是**从右向左**运算的。

2）大概的优先级顺序⬇️：

​	**第一优先级：**(),++,--

​	**第二优先级：**单目运算

​	**第三优先级：**算术运算符

​	**第四优先级**：移位运算符

​	**第五优先级：**关系运算符

​	**第六优先级：**位运算符

​	**第七优先级：**逻辑运算符

​	**第八优先级：**赋值运算符

​	**第九优先级：**逗号

## 2.8 获取用户终端输入

```go

var name string
// 1.fmt.Scanln 将变量地址传入函数，这样输入的值才能直接影响到这个变量 
fmt.Scanln(&name)
// 2.fmt.Sanf 可以按照指定格式输入，依然传入的是变量地址
var sex string
var age int
fmt.Scanf("%s %d", &sex, &age)
```

## 2.9 计算机进制（补基础）

### 2.9.1 进制分类

#### 2.9.1.1 二进制

用 0 和 1 表示，满 2 进 1 。

注意⚠️：

1）**在Golang中，不能直接用二进制表示一个整数**（沿用了c的特点），但**可以用格式化输出二进制**( fmt.Printf("%b" , 10) )。

2）**原码、反码、补码**

 	**|_对于有符号的而言：**

​		1）二进制的最高位是符号位，0表示正数，1表示负数。

​		2）正数的原码，反码，补码都一样

​		3）负数的反码 = 它的原码符号位不变，其他位去反。

​		4）负数的补码 = 它的反码 + 1

​		5）在计算机运算的时候，都是以补码的方式来运算的。





#### 2.9.1.2 八进制

用0 - 7 表示，满 8 进 1.

注意⚠️：在Golang中，**可以直接用八进制表示一个整数**，以**数字 0 开头**。(var j int = 011 , 011=>9)

#### 2.9.1.3 十六进制

用 0 - 9 以及 A-F 表示，满 16 进 1.

注意⚠️：在Golang中，**可以直接用十六进制表示一个整数**，以**数字 0x 或 0X 开头**。(var j int = 0x11 , 011=>17)

### 2.9.2 进制的转换

#### 2.9.2.1 其他进制转十进制

**N进制转十进制**：从最低位开始（右），每个位上的数提取出来，乘上**N**的**（位数-1）次方**，然后求和。（一般就二进制、八进制、十六进制 转十进制。）

#### 2.9.2.2 十进制转其他进制

**十进制转N进制：**将该数**不断除以N**，直到**商为零**（也就是被除数比除数还小了），然后**将每步得到的余数倒过来（从右向左）**，就是对应的N进制。

<img src="/Users/mac/Desktop/截屏2024-04-14 上午9.02.14.png" alt="截屏2024-04-14 上午9.02.14" style="zoom:40%;" />

#### 2.9.2.3 二进制转八进制、十六进制

**二进制转八进制：**将二进制数**每三位一组（从低位开始组合）**（因为三位可以表示0-7，为八进制每一位的范围），**转成对应的八进制数**即可。

**二进制转十六进制：**将二进制数**每四位一组（从低位开始组合）**（因为四位可以表示0-F，为十六进制每一位的范围），**转成对应的十六进制数**即可。

#### 2.9.2.4 八进制、十六进制转二进制

**八进制转二进制：**将八进制数的**每一位**，**转换为对应的一个3位的二进制数**即可。

**十六进制转二进制：**将十六进制数的每一位，**转换为对应的一个4位的二进制数**即可。

# 3 程序流程控制

## 3.1 顺序控制

**定义：**程序从上到下逐行执行，中间没有判断和跳转。（就是日常写的最普通的代码，默认就是从上到下逐行执行的）

**注意⚠️：**Golang定义**变量**时**采用合法的前向引用**。（就是先声明后使用）

## 3.2 分支控制if-else

**定义：**就是让程序有选择的执行。

### 3.2.1 单分支

if **条件表达式** { 执行代码块 }

**注意⚠️：**

1）{}必须有，就算只有一行代码。

2）Golang**支持在if中直接定义一个变量，形式比较特殊**。if age := 20; age>18 { }，但**这个变量（如age）的作用域仅在这个if语句中，是一个局域变量**。



### 3.2.2 双分支if-else

if **条件表达式** { 执行代码块1 } else{ 执行代码块2 }

注意⚠️：**else要和if的第二个大括号在同一行**，换行直接报错。



### 3.2.3 多分支if-else if-else

if **条件表达式** { 执行代码块1 } else if { 执行代码块2 } else{ 执行代码块3 }

**注意⚠️：**

1）多分支**最终只能有一个入口**。（一旦有一个入口进入了，其他的就不会再判断了，会直接退出多分支）

2）else不是必须的。

3）如果不写else，前面判断都为假，最终没有入口。



### 3.2.4 嵌套分支

if **条件表达式** { if { 执行代码块2 } } 

注意⚠️：

1）嵌套分支不要太多，建议控制在3层以内。



### 3.2.5 switch分支结构

```go
switch 表达式{
  case 表达式1,表达式2,...:
  case 表达式3,表达式4,...:
  	执行代码块
  ...
  default:
  	执行代码块
}
```

**注意⚠️：**

1）case匹配后，进入执行代码块，这里面**不再需要加break（会自动退出）**

2）**每一个case是唯一的**，**从上到下**逐一测试，直到匹配为止。

3）**case后面表达式可以有多个**，逗号隔开，满足一个就执行

4）switch和case后面是一个表达式（即：常量、变量、一个有返回值的函数）

5）case后面各个表达式的值的数据类型必须和switch的表达式数据类型一致。

6）case后面的表达式如果是常量值（比如10，20，直接能看出来的），则**要求不能重复**。（但如果是变量，即使实际值一样，它一眼看不出来，不会报错）

7）default语句不是必须的。

8）**switch后面可以不带表达式**，类似if-else使用。

```go
var age int = 10

switch{
	case age == 10 :
  	fmt.Prinln("ok")
  case age > 10 :
  	fmt.Prinln("ok2")
  default:
  	fmt.Prinln("不及格")
}
```

9）switch后面也可以直接 声明/定义 一个变量，分号结束。不推荐。

```go
switch age := 10; {
	case age == 10 :
  	fmt.Prinln("ok")
  case age > 10 :
  	fmt.Prinln("ok2")
  default:
  	fmt.Prinln("不及格")
}
```

10）**switch穿透 - fallthrough**，如果在case语句块后面增加fallthrough，则会继续直接执行下一个case（**不做下一个case判断了；且默认只穿透一**层），也叫switch穿透。不建议多用。

```go
var num int = 10

switch num {
case 10 :
  fmt.Println("ok1")
  fallthrough // 打印ok1，接着穿透到下一层，打印ok2
case 20 :
  fmt.Println("ok2")
default:
  fmt.Println("ok3")
}
```

11）Type Switch：switch语句可以用于type- switch来判断某个interface变量中实际指向的变量类型。

```go
var x interface{}
var y = 10.0
x = y
switch i := x.(type) {
  case int:
  	fmt.Printf("x 的类型 : %T", i)
}
```

12）如果case处也加范围判断等（比如用==、>、<），就很像if-else分支结构了，一般还是用case 10，case 9感觉更有价值（**如果有时候真的是范围判断，却想用switch的话，可以做一些范围处理**）。

**switch和if的比较：**

1）判断**具体数值不多**，符合整数、浮点数、字符、字符串，建议switch。**switch简洁高效**。

2）**区间判断** 和 **结果为bool类型** 的判断，还是if。**if使用范围更广**。

## 3.3 循环控制for

### 3.3.1 单重循环-for循环

**基本语法：** for **循环变量初始化**; **循环条件**; **循环变量迭代**{ **循环体** } 

**for循环的四要素：** **循环变量初始化**；**循环条件**；**循环变量迭代**；**循环体** 

**for循环执行的顺序说明：**

 1）循环变量初始化 

2）执行循环条件 

3）如果循环条件为真，执行循环体

4）执行循环变量迭代

5）反复执行2）3）4），直到循环条件为false，退出for循环

<img src="/Users/mac/Desktop/markdown笔记/BackEnd-system/GolangNoteImage/截屏2024-04-17 下午3.43.27.png" alt="截屏2024-04-17 下午3.43.27" style="zoom:50%;" />

**注意⚠️：**

1）**循环条件**必须是一个**返回布尔值**的表达式

2）for循环第二种使用方式：将 变量初始化 和 变量迭代 写到其他位置。

```go
j := 1 // 循环变量初始化
for j <= 10 { // 循环条件
  //循环体
  j++ //循环变量迭代
}
```

3）for循环第三种使用方式：for {} 等价于for ; ; {} ，**这是一个无限循环，需要配合break使用**。

4）Golang还有for-range的方式，可以方便遍历字符串和数组

```go
//for-传统方式 遍历字符串
var str0 string = "hello,world"
for i :=0 ; i<len(str0) ; i++{
  fmt.Println(str0[i])
}

//注意⚠️：如果我们的字符串含有中文，传统遍历字符串的方式是错误的，出现乱码。因为对字符串遍历是按照字节来的，而一个汉字在utf8编码对应3个字节。
//解决❗️：把 str 转为 []rune，
var str1 string = "你好"
str2 := []rune(str)
for i :=0; i < len(str2); i++ {
  fmt.Println(str2[i])
}


//for-range 遍历字符串
var str string = "hello"
for index, val := range str {
  fmt.Println(index, val) // 0 h
}
//注意⚠️：for-range默认使用字符方式遍历，因此有中文也正确。（但打印出index会跳3，比如0，3，6。index还是按字节统计的）

```

**5）Golang没有while和do while**

### 3.3.2 多重循环-for循环

**注意⚠️：**

1）建议一般用两层嵌套循环，最多不要超过3层

2）嵌套循环就是把内层循环当成外层循环的循环体

3）外层循环m次，内层为n次，则内层循环体实际上需执行 **m*n = mn** 次 

**编程两大绝招：**

1）先易后难，即将一个复杂的问题分解成简单的问题

2）先死后活，先写死，再用变量做活。

### 3.3.3 跳转控制语句

#### 3.3.3.1 break

```go
package main
import(
	"fmt"
	"math/rand"
  "time"
)

func main(){
  for {
      //time.Now().Unix()返回的是当前时间的时间戳
      rand.Seed(time.Now().Unix())
      //注意⚠️：如果直接下面这个语句而不设置随机种子的话，是 ❗️伪随机数❗️，每一次循环打印的是一样的
      n := rand.Intn(100) //[0,100)
      if(n == 99){
        break
      	}
      }
}
```

**注意⚠️：**

1）break语句出现在多层嵌套语句块中，可以通过标签指明要终止哪一层语句块。

```go
label2：
for i:=0; i<4; i++{
  label1: //设置一个标签
  for j :=0; j<10;j++{
    if j==2{
      //等价于 break label1
      //1⃣️break默认跳出离它最近的for循环 
      break 
      //2⃣️break后面制定标签，跳出标签对应的for循环
    }
    fmt.Println("j",j)
  }
}
```

#### 3.3.3.2 continue

**注意⚠️：**

1）continue语句用于结束本次循环（也就是本次循环continue后面的循环体语句不再执行），继续执行下一次循环

2）continue语句出现在多层嵌套语句块中，可以通过标签指明要跳过哪一层语句块。（用法类似break语句）

#### 3.3.3.3 goto

1）Golang中的goto语句可以**无条件地转移到程序中指定的行**（搭配label使用）

2）一般不主张使用goto语句

#### 3.3.3.4 return

1）在**普通**方法或者函数中使用，表示**跳出（终止）所在方法或函数**。

2）在**main函数**中使用，表示终止main函数，也就是说**终止程序**。

# 4 函数、包、错误处理

## 4.1 函数

### 4.1.1 函数定义和基本语法

**定义：**为完成某一功能的程序指令（语句）的集合，称为函数。Golang中函数分为：自定义函数、系统函数。

```go
//❗️返回值列表写的就是返回值的数据类型。
//❗️如果没有返回值，返回值列表不需要写
func 函数名（行参列表）（返回值列表）{
  执行语句
  // golang支持多个返回值
  return 返回值列表
}

//	示例
func cal(n1 float64, n2 float64, operator byte) float64 {
  var res float64
  //
  return res
}
```

### 4.1.2 函数调用机制

**栈区：**基本数据类型**一般**分配在栈区。（一般，编译器存在一个逃逸分析）

**堆区：**引用数据类型**一般**分配在堆区。（一般，编译器存在一个逃逸分析）

**代码区：**代码存放在这里。

1）调用一个函数，给该函数（被调用的函数）分配一个新空间，编译器通过自身的处理让这个新空间和其他栈的空间区分开来。

2）在每个函数对应的栈中，数据空间是独立的，不会混淆。

3）当一个函数调用完毕（执行完毕）后，程序会销毁这个函数对应的栈空间。

**注意⚠️**：

1）如果返回多个值，在接收时，希望忽略某个返回值，则**使用_符号表示占位忽略**

2）如果返回值只有一个，（返回值列表）可以不写（）。



### 4.1.3 函数递归调用

**定义：**一个函数在函数体内又调用了自身。

**注意⚠️：**

1）执行一个函数时，就创建一个新的受保护的独立空间（**调用一次自身也就开辟了一个新函数栈**）

2）函数的局部变量是独立的，不会相互影响

3）递归必须向递归条件逼近，否则就是无限递归。（**递归必须有终止条件**）

4）当一个函数执行完毕，或者遇到return返回，谁调用，结果就返回给谁；同时该函数（被调用的这个函数）本身也会被销毁。

## 4.2 包

**包的定义：**go的每一个文件都是属于一个包的，也就是说go是以包的形式来管理文件和项目目录结构的。

**包的本质**：包的本质就是创建不同的文件夹，来存放程序文件。

**包的三大作用：**

1）区分相同名字的函数、变量等标识符（就是把相同的标识符名称放在不同的包）

2）当程序文件很多时，可以很好的管理项目

3）控制函数、变量等访问范围，即作用域 ( 包当中的函数名大小写，同样控制public还是private )

**包的具体使用：**

1）**打包基本语法：**package 包名

2）**引入包的基本语法：**import "包的路径"（默认从src下面开始引）

3）**使用包的基本语法：**包名.函数名( )

**注意⚠️：**

1）一个文件打包，这个包对应一个文件夹。文件的包名**一般**和文件所在的文件夹名一致，一般为**小写字母**。

2）**package指令在文件第一行**，然后是import指令。

3）import包时，路径从$GOPATH的src下开始（不带src）

4）为了让其他包的文件可以访问到本包的函数，该函数名要大写（public），这样才能跨包访问。

5）包名可取别名，但**起了别名后原先的包名就不能使用了**

```go
//给 utils 包起了一个别名 util
import util "go_code/utils"
```

6）**一个包下不能有相同的函数名和全局有变量名（否则报重复定义错误）**。（不仅是同一个文件下不能有相同函数名，同一个包下的不同文件也不允许有相同的函数名）

7）**只有main包（package main）才可以编译成一个可执行程序文件**；如果只是写一个库，包名可自定义（库编译会生成一个.a库文件，比如utils.a）。
